<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Logic Programming with Pytholog - pytholog</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Logic Programming with Pytholog";
    var mkdocs_page_input_path = "How pytholog works.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> pytholog</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Logic Programming with Pytholog</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting Started</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#memoization">Memoization</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#nested-rules">Nested rules</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#constraint-satisfaction-problem">Constraint Satisfaction Problem</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#image-source-seven-languages-in-seven-weeks-book">Image source: Seven Languages in Seven Weeks Book</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#probabilistic-logic">Probabilistic Logic</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#rules-from-machine-learning">Rules from Machine Learning</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#helper-functions">Helper Functions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#graph-traversals-with-pytholog">Graph Traversals with Pytholog</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#image-source">Image Source</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../friends_influence/">Probabilistic Logic</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../pytholog_database/">Pytholog as a logic database</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../pytholog_graph/">Finding paths in graphs</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">pytholog</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Logic Programming with Pytholog</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="logic-programming-with-pytholog">Logic Programming with Pytholog</h1>
<h2 id="getting-started">Getting Started</h2>
<p><strong>Installation</strong></p>
<pre><code class="bash">pip install pytholog
</code></pre>

<pre><code class="python">import pytholog as pl
</code></pre>

<p><strong>Defining a knowledge base object to store the facts and rules.</strong></p>
<pre><code class="python">new_kb = pl.KnowledgeBase(&quot;flavor&quot;)
new_kb([&quot;likes(noor, sausage)&quot;,
        &quot;likes(melissa, pasta)&quot;,
        &quot;likes(dmitry, cookie)&quot;,
        &quot;likes(nikita, sausage)&quot;,
        &quot;likes(assel, limonade)&quot;,
        &quot;food_type(gouda, cheese)&quot;,
        &quot;food_type(ritz, cracker)&quot;,
        &quot;food_type(steak, meat)&quot;,
        &quot;food_type(sausage, meat)&quot;,
        &quot;food_type(limonade, juice)&quot;,
        &quot;food_type(cookie, dessert)&quot;,
        &quot;flavor(sweet, dessert)&quot;,
        &quot;flavor(savory, meat)&quot;,
        &quot;flavor(savory, cheese)&quot;,
        &quot;flavor(sweet, juice)&quot;,
        &quot;food_flavor(X, Y) :- food_type(X, Z), flavor(Y, Z)&quot;,
        &quot;dish_to_like(X, Y) :- likes(X, L), food_type(L, T), flavor(F, T), food_flavor(Y, F), neq(L, Y)&quot;])
</code></pre>

<p>Note that <strong>neq()</strong> is pytholog's way to apply <strong>inequality</strong> so here "neq(L, Y)" means L != Y meaning that we look for new dishes not the one already liked by the person in the query.</p>
<p>OR can be implemented with defining the rules as many times as the OR facts. For example, to say "fly(X) :- bird(X) ; wings(X)." can be defined as two rules as follows: "fly(X) :- bird(X)." and "fly(X) :- wings(X)."</p>
<p>Let’s do some queries in this database using its facts and rules.</p>
<pre><code class="python">new_kb.query(pl.Expr(&quot;likes(noor, sausage)&quot;))
# ['Yes']
</code></pre>

<pre><code class="python">new_kb.query(pl.Expr(&quot;likes(noor, pasta)&quot;))
# ['No']
</code></pre>

<h2 id="memoization">Memoization</h2>
<p>I added <strong>Memoization</strong> to speed up the queries.</p>
<p>Wikipedia definition: In computing, memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.</p>
<p>Let’s test it doing the same query twice and compare time used to do the
query.</p>
<pre><code class="python"># query 1
from time import time
start = time()
print(new_kb.query(pl.Expr(&quot;food_flavor(What, sweet)&quot;)))
print(time() - start)

# [{'What': 'limonade'}, {'What': 'cookie'}]
# 0.0020236968994140625
</code></pre>

<pre><code class="python"># query 2
start = time()
print(new_kb.query(pl.Expr(&quot;food_flavor(Food, sweet)&quot;)))
print(time() - start)

# [{'Food': 'limonade'}, {'Food': 'cookie'}]
# 0.0
</code></pre>

<p>As you see, it took almost no time to return the same answer again and
it also takes care of different Uppercased variable inputs as they
anyways will be the same result no matter what they are.</p>
<h2 id="nested-rules">Nested rules</h2>
<p>Now we will use the <strong>dish_to_like</strong> rule to recommend dishes to
persons based on taste preferences.</p>
<pre><code class="python">start = time()
print(new_kb.query(pl.Expr(&quot;dish_to_like(noor, What)&quot;)))
print(time() - start)

# [{'What': 'gouda'}, {'What': 'steak'}]
# 0.001992940902709961
</code></pre>

<p>Let’s test the Memoization again:</p>
<pre><code class="python">start = time()
print(new_kb.query(pl.Expr(&quot;dish_to_like(noor, What)&quot;)))
print(time() - start)

# [{'What': 'gouda'}, {'What': 'steak'}]
# 0.0
</code></pre>

<h2 id="constraint-satisfaction-problem">Constraint Satisfaction Problem</h2>
<p><strong>City Coloring problem</strong></p>
<p><img alt="city color" src="/img/city_color.png" /></p>
<h6 id="image-source-seven-languages-in-seven-weeks-book">Image source: <a href="https://pragprog.com/titles/btlang/seven-languages-in-seven-weeks/">Seven Languages in Seven Weeks Book</a></h6>
<p>The problem is <strong>Constraint Satisfaction Problem</strong>. The problem is to
color each city using only three colors but no adjacent cities can be
colored the same. The problem might seem so easy but it’s really
challenging how to tell this to a machine. But using prolog logic it is
kind of easier because all you have to do is to specify the rules of the
problem and prolog will answer.</p>
<pre><code class="python">## new knowledge base object
city_color = pl.KnowledgeBase(&quot;city_color&quot;)
city_color([
    &quot;different(red, green)&quot;,
    &quot;different(red, blue)&quot;,
    &quot;different(green, red)&quot;, 
    &quot;different(green, blue)&quot;,
    &quot;different(blue, red)&quot;, 
    &quot;different(blue, green)&quot;,
    &quot;coloring(A, M, G, T, F) :- different(M, T),different(M, A),different(A, T),different(A, M),different(A, G),different(A, F),different(G, F),different(G, T)&quot;
])
</code></pre>

<p>Let’s query the answer:</p>
<pre><code class="python">## we will use [0] to return only one answer 
## as prolog will give all possible combinations and answers
city_color.query(pl.Expr(&quot;coloring(Alabama, Mississippi, Georgia, Tennessee, Florida)&quot;), cut = True)

# {'Alabama': 'blue',
#  'Mississippi': 'red',
#  'Georgia': 'red',
#  'Tennessee': 'green',
#  'Florida': 'green'}
</code></pre>

<h2 id="probabilistic-logic">Probabilistic Logic</h2>
<p>Now let's try to play with some probabilities.
First in prolog <strong>"is"</strong> is used to assign the result of operations. 
For example, if we want to say "A = 3 * 4", we say "A is 3 * 4", not "A = 3 * 4" because this is unification not assignment.</p>
<p>Let's define some dummy knowledge base with probabilities and query them:
<em>The numbers are totally dummy and have no meanings just to explain the functionality.</em></p>
<pre><code class="python">battery_kb = pl.KnowledgeBase(&quot;battery&quot;)
battery_kb([
    &quot;battery(dead,P) :- voltmeter(battery_terminals,abnormal,P2), P is P2 + 0.5&quot;,
    &quot;battery(dead,P) :- electrical_problem(P), P &gt;= 0.8&quot;,
    &quot;battery(dead,P) :- electrical_problem(P2), age(battery,old,P3), P is P2 * P3 * 0.9&quot;,
    &quot;electrical_problem(0.7)&quot;,
    &quot;age(battery,old, 0.8)&quot;,
    &quot;voltmeter(battery_terminals,abnormal,0.3)&quot;])

battery_kb.query(pl.Expr(&quot;battery(dead, Probability)&quot;))

# [{'Probability': 0.8}, {'Probability': 'No'}, {'Probability': 0.504}]
# the second one is &quot;No&quot; because the condition has not been met.
</code></pre>

<h2 id="rules-from-machine-learning">Rules from Machine Learning</h2>
<p><strong>Taking rules from Machine Learning model and feed them into knowledge base then try to predict new instances.</strong></p>
<p>This shows beneficial for <strong>Explainable AI</strong>. One can explain why a model predicts specific prediction.</p>
<p>Let's suppose that we have these rules from a Decision Tree Model to classify iris flowers. And we have a new record for which we try to predict using the rules.</p>
<pre><code class="python">iris_kb = pl.KnowledgeBase(&quot;iris&quot;)
iris_kb([## Rules
    &quot;species(setosa, Truth) :- petal_width(W), Truth is W &lt;= 0.80&quot;, 
    &quot;species(versicolor, Truth) :- petal_width(W), petal_length(L), Truth is W &gt; 0.80 and L &lt;= 4.95&quot;,
    &quot;species(virginica, Truth) :- petal_width(W), petal_length(L), Truth is W &gt; 0.80 and L &gt; 4.95&quot;,
    ## New record
    &quot;petal_length(5.1)&quot;,
    &quot;petal_width(2.4)&quot;])
</code></pre>

<p>Now let's try to predict the class:</p>
<pre><code class="python">iris_kb.query(pl.Expr(&quot;species(Class, Truth)&quot;))

# [{'Class': 'setosa', 'Truth': 'No'},
#  {'Class': 'versicolor', 'Truth': 'No'},
#  {'Class': 'virginica', 'Truth': 'Yes'}]
</code></pre>

<p>Now let's extract the rules for some goal or fact.</p>
<pre><code class="python">iris_kb.rule_search(pl.Expr(&quot;species(Species, Truth)&quot;))

# [species(setosa,Truth):-petal_width(W),TruthisW&lt;=0.80,
#  species(versicolor,Truth):-petal_width(W),petal_length(L),TruthisW&gt;0.80andL&lt;=4.95,
#  species(virginica,Truth):-petal_width(W),petal_length(L),TruthisW&gt;0.80andL&gt;4.95]
</code></pre>

<p>So now we can see the rules why a model chooses a prediction and explain the behavior.</p>
<h2 id="helper-functions">Helper Functions</h2>
<p><strong>clear_cache()</strong> is used to clean the cache inside the knowledge_base:</p>
<pre><code class="python">new_kb.clear_cache()
</code></pre>

<p><strong>from_file()</strong> is used to read facts and rules from a prolog ,pl, or txt file:</p>
<pre><code class="python">example_kb = pl.KnowledgeBase(&quot;example&quot;)
example_kb.from_file(&quot;/examples/example.txt&quot;)
# facts and rules have been added to example.db
example_kb.query(pl.Expr(&quot;food_flavor(What, savory)&quot;))
# [{'What': 'gouda'}, {'What': 'steak'}, {'What': 'sausage'}]
</code></pre>

<p>Also we can constructs rules or facts looping over dataframes:</p>
<pre><code class="python">import pandas as pd
df = pd.DataFrame({&quot;has_work&quot;: [&quot;david&quot;, &quot;daniel&quot;], &quot;tasks&quot;: [8, 3]})
df
#   has_work  tasks
#0     david      8
#1    daniel      3
ex = pl.KnowledgeBase()
for i in range(df.shape[0]):
    ex([f&quot;has_work({df.has_work[i]}, {df.tasks[i]})&quot;])

ex.db
# {'has_work': {'facts': [has_work(david,8), has_work(daniel,3)],
#   'goals': [[], []],
#   'terms': [['david', '8'], ['daniel', '3']]}}
</code></pre>

<h2 id="graph-traversals-with-pytholog">Graph Traversals with Pytholog</h2>
<p>Let's define a weighted directed graph and see if we can get a path, hopefully the shortest, between two nodes using breadth first search.</p>
<p><img alt="graph" src="/img/graph.png" /></p>
<h6 id="image-source"><a href="https://dtai.cs.kuleuven.be/problog/tutorial/basic/04_pgraph.html">Image Source</a></h6>
<pre><code class="python">graph = pl.KnowledgeBase(&quot;graph&quot;)
graph([
    &quot;edge(a, b, 6)&quot;, &quot;edge(a, c, 1)&quot;, &quot;edge(b, e, 4)&quot;,
    &quot;edge(b, f, 3)&quot;, &quot;edge(c, d, 3)&quot;, &quot;edge(d, e, 8)&quot;,
    &quot;edge(e, f, 2)&quot;,
    &quot;path(X, Y, W) :- edge(X , Y, W)&quot;,
    &quot;path(X, Y, W) :- edge(X, Z, W1), path(Z, Y, W2), W is W1 + W2&quot;])

answer, path = graph.query(pl.Expr(&quot;path(a, f, W)&quot;), show_path = True)
print(answer)
print([x for x in path if str(x) &gt; &quot;Z&quot;])

# [{'W': 9}, {'W': 12}, {'W': 14}]
# ['d', 'b', 'e', 'c']
</code></pre>

<p>Now with the <strong>show_path</strong> argument we can see the nodes the search passed by and we can see it gave all the possible answers and the first one is the best.
So let's use the <strong>cut</strong> argument to get only the first result and stop the search.</p>
<pre><code class="python">answer, path = graph.query(pl.Expr(&quot;path(a, e, W)&quot;), show_path = True, cut = True)
print(answer)
print([x for x in path if str(x) &gt; &quot;Z&quot;])

# [{'W': 10}]
# ['b']
</code></pre>

<p>Future implementation will try to come up with ideas to combine this
technique with <strong>machine learning algorithms and neural networks</strong></p>
<p><strong>Contribution, ideas and any kind of help will be much appreciated</strong></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../friends_influence/" class="btn btn-neutral float-right" title="Probabilistic Logic">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../friends_influence/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
